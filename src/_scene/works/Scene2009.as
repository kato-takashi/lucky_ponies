package _scene.works{	import jp.progression.casts.*;	import jp.progression.commands.display.*;	import jp.progression.commands.lists.*;	import jp.progression.commands.managers.*;	import jp.progression.commands.media.*;	import jp.progression.commands.net.*;	import jp.progression.commands.tweens.*;	import jp.progression.commands.*;	import jp.progression.data.*;	import jp.progression.events.*;	import jp.progression.loader.*;	import jp.progression.*;	import jp.progression.scenes.*;		import ui.*;	import ui.bg.*;	import _scene.*;	import ui.Scroll_bar.*	import _sprite.*;		import flash.net.URLRequest;	import jp.nium.utils.XMLUtil;	import flash.display.Sprite;		/**	 * ...	 * @author ...	 */	public class Scene2009 extends SceneObject {				/**		 * 新しい MySceneObject インスタンスを作成します。		 */		private var _logo_btn_:logo_btn;		private var _Works_bg:Works_bg;		private var _year2009:year2009;				////////xml関係		//public var _btn_Close:Btn_Close;		public var _arr_Thum_works:Array;		private var scrollBar:Scrollbar;		private var masker:Masker;		private var Retsu:uint;		private var base_Square:Sprite;		private var _close_btn:close_btn;				public function Scene2009( name:String = null, initObject:Object = null ) {			// 親クラスを初期化する			super( name, initObject );						// シーンタイトルを設定します。			title = "2009_Works _ LuckyPonies Web _ Kato & Kato Design.";						Retsu = 5;			//logoButton = new LogoButton();						//addSceneFromXML用のシーンの参照			ImageScene;					}				/**		 * シーン移動時に目的地がシーンオブジェクト自身もしくは子階層だった場合に、階層が変更された直後に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneLoad():void {			_logo_btn_ = new logo_btn();			_Works_bg = new Works_bg();			_Works_bg.x = -300			_Works_bg.y = 52;			_Works_bg.alpha = 0;			//_Works_bg.y = -800;						_year2009 = new year2009();			_year2009.y = -48						_close_btn = new close_btn();						//////////			base_Square = new Sprite();			//base_Square.graphics.beginFill(0xFFCC00);            base_Square.graphics.drawRect(0, 0, 0, 0);						////////close_btnのID			var sId:SceneId = new SceneId("/index/works")						addCommand(			//シーン作成用のXMLファイルを読み込み				new LoadURL(new URLRequest("xml/works_xml/2009XML/scene2009data.xml")),				////////////////				new AddChild(manager.root.container, _Works_bg),				new AddChild(_Works_bg, base_Square),				new AddChild(_Works_bg, _close_btn),				new Prop(base_Square, { x:0, y:0, alpha:2 } ),				new Prop(_close_btn, { x:600, y:0, alpha:1 ,sceneId:sId } ),								////////////////HTML用				//new LoadURL( new URLRequest( "ArchivePhoto/GAarchive/deploy/HTMLscenedata.xml" ) ),				function():void {										//シーンの作成（コマンドクラスのlatestDataプロパティで、直近の読み込みデータを参照可能）					addSceneFromXML(new XML(this.latestData));										//コマンド登録用のパラレルリスト					var pList:ParallelList = new ParallelList();					//削除用の参照を配列に入れておく					_arr_Thum_works = new Array();										//ボタンの作成					for ( var i:int = 0; i < numScenes; i++ ) {						//シーン固有の値をsceneinfo.dataより取得(シーンオブジェクトのscenesプロパティで子シーンの参照の配列を取得可能)						var xmlData:XMLList = new XMLList( scenes[i].dataHolder.data );						//データ形式がXMLListなので、XMLUtilを利用して変換						var obj:Object = jp.nium.utils.XMLUtil.xmlToObject( xmlData );						//画像をボタンとして作成（画像クリックで戻る様にする為）、また、ボタンはスプライトに内包する						var btn_Thumbnail:Btn_Thumbnail_Sprite = new Btn_Thumbnail_Sprite();						//削除時の為にボタンのインスタンスの参照を保持						_arr_Thum_works.push(btn_Thumbnail);												//setterへ値をセットする						btn_Thumbnail.sceneId = scenes[i].sceneId;						//btn_Thumbnail.imageUrl = obj.imageUrl;						btn_Thumbnail.imageUrl = obj.imageUrl;						btn_Thumbnail.thumb = obj.thumb;						//位置の決定						btn_Thumbnail.x = ( 110 * (i % Retsu ) ) ;						btn_Thumbnail.y = (Math.floor(i / Retsu) * 80) + _year2009.y+_year2009.height;						//trace(obj.thumb);						pList.addCommand(										 new AddChild(base_Square, btn_Thumbnail )							//new AddChild(base_Square, btn_Thumbnail )													);					}					insertCommand(pList);				}//, 				//new AddChild(_Works_bg, base_Square),				//new AddChild(manager.root.container, _Works_bg)								);									masker = new Masker();			masker.x = base_Square.x;			masker.y = (Math.floor(0 / Retsu) * 80) + _year2009.y+_year2009.height;			masker.width =  ((130 * (Retsu-1 % Retsu ))  + 50) - ((130 * (0 % Retsu ))  );			masker.height = Math.floor(Retsu*2 / Retsu) * 80 + 30*5;			_Works_bg.addChild(masker);			scrollBar = new Scrollbar(base_Square, masker);			_Works_bg.addChild(scrollBar);								}				/**		 * シーンオブジェクト自身が目的地だった場合に、到達した瞬間に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneInit():void {			addCommand(					   					   new AddChild(_Works_bg, _year2009),					   new DoTweener( _Works_bg , {  alpha:0.5, x:_logo_btn_.width , time:.2 , transition:"easeOutCirc" } )					   );				}				/**		 * シーンオブジェクト自身が出発地だった場合に、移動を開始した瞬間に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneGoto():void {			addCommand(			);					   		}				/**		 * シーン移動時に目的地がシーンオブジェクト自身もしくは親階層だった場合に、階層が変更される直前に送出されます。		 * このイベント処理の実行中には、ExecutorObject を使用した非同期処理が行えます。		 */		override protected function atSceneUnload():void {			addCommand(								[new DoTweener( _Works_bg , {  alpha:0 ,x:300 , time:.2 , transition:"easeOutCirc" } )					   ],					[function ():void {					for (var i:int = 0; i < _arr_Thum_works.length; i++) {						new RemoveChild(base_Square, _arr_Thum_works[i]);					}					},					   new RemoveChild(container,_Works_bg),					   new RemoveChild(_Works_bg, base_Square),			           new RemoveAllChildren(this),								removeAllScenes]			);		}	}}